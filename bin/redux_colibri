#!/bin/bash

cmd="$0 $@"

file_list=$1
shift

grb_RA=
grb_DEC=
filter=w

#matching,wcs
ps=0.0001056 # platescale
nstars_min=5 # per 1k
mask_sigma=6.0
bg_order=8
snr_cut=5.0
p1=-0.00584

# base reduction
inst=coatli
sat_level=65000.0
gain=2.1
RN=6.9
#detect_thresh=0.5
detect_thresh=1.0
NO=48 # overscan width
ns=4096 # new size for images (default is no change)

do_nir_sky=yes
new_mask=yes # build a new source mask instead of using existing

use_ddoti_phot=yes  # photometry from the ddoti pipeline instead of coatli pipeline

full_stack=no

do_dao=yes

make_frame_jpegs=yes

cleanup=yes

while [ $# -gt 0 ] ; do eval $1 ; shift ; done

[ -s $file_list ] || { echo "No file $file_list" ; exit 1 ; }

gethead -a FILTER @$file_list | eval awk "'{if(\$2==\"$filter\") print \$1}'" > tmp_file_list$$.txt

[ -s tmp_file_list$$.txt ] || { echo "No filter $filter in file list $file_list" ; exit 2 ; }

file0=`head -1 tmp_file_list$$.txt`
[ -f $file0 ] || { echo "Cannot find first file $file0" ; exit 3 ; }
nfiles0=`cat tmp_file_list$$.txt | wc -l`

file1=`tail -1 tmp_file_list$$.txt`
rm tmp_file_list$$.txt 2>/dev/null
ny_min=`gethead -a ZNAXIS2 @$file_list | sort -n -k 2 | awk '{print $2;exit}'`
pos_err0=`gethead ALUN $file1 | awk '{if($1<0.1) printf("%.6f\n",$1)}'`

[ "$pos_err0" ] && ns=2048  # new_size, for error regions smaller than 0.1 degrees
ny_min=`gethead -a ZNAXIS2 @$file_list | sort -n -k 2 | awk '{print $2;exit}'`
if [ "$ny_min" -lt 4096 ]; then
    ns=$ny_min
    bg_order=`echo $bg_order $ns | awk '{printf("%.0f\n",$1*$2/4096)}'`
fi

go_iter=0
function gonogo() {
    ((go_iter++))
    [ "$((go_iter%NBATCH))" -eq 0 ] && wait
}

cam=`basename $file0 | cut -c16-17`
[ "$cam" = "C0" ] && cam=C1
tag=${cam}_$filter

if [ "$cam" = "C1" ]; then
    gain=2.2
    RN=6.8
fi

if [ "$cam" = "C2" ]; then
    gain=2.1
    RN=7.0
fi

sg=`gethead SOFTGAIN $file0`
if [ "$sg" -gt 1 ]; then
    sat_level=`echo "$sat_level $sg" | awk '{printf("%.1f\n",$1/$2)}'`
    gain=`echo "$gain $sg" | awk '{printf("%.1f\n",$1*$2)}'`
fi

dte=`date -u +20%y%m%d_%H%M%S`
dte1=`basename $file0 | sed -e 's/f//g' -e 's/C/ /g' | awk '{print $1}'`
me=`basename $0`
here=`pwd`
here_str=`echo $here | tr '/' '_'`

catdir=${here}/catalogs
biasdir=${here}/biases
darkdir=${here}/darks
flatdir=${here}/flats
#workdir=${here}/${me}_$tag
workbase=${REDUX_WORK_BASE_DIR}/${here_str}_${me}  # do the work locally
workdir=${workbase}/${me}_$tag
[ -d $catdir ] || mkdir $catdir
[ -d $biasdir ] || mkdir $biasdir
[ -d $darkdir ] || mkdir $darkdir
[ -d $flatdir ] || mkdir $flatdir
if [ -f "${workdir}/force_cleanup.txt" ]; then
     echo "Cleaning up and starting fresh."
     rm -r $workdir
fi
[ -d "$workdir" ] || mkdir -p $workdir
#ln -s $workdir $here 2>/dev/null
echo $workbase > ${here}/workdir.txt
echo 0 > $workdir/current_state.txt

logfile=${me}_${dte}_${tag}_$$.log
failed=no
rm ${workdir}/*log 2>/dev/null
echo "Working in directory $workdir, logging to ${workdir}/$logfile"
exec > ${workdir}/$logfile 2>&1
t00=`date +%s`

date -u
echo $cmd

echo "Using $ns x $ns of image center for all frames"

# copy the data into the current directory
bin=`gethead BINNING $file0`
[ "$bin" ] || bin=1
if [ "$bin" -gt 1 ]; then
    sat_level=`echo $sat_level $bin | awk '{printf("%.0f\n",$1*$2*$2)}'`
    ps=`echo "$ps $bin" | awk '{printf("%.6f\n",$1*$2)}'`
    RN=`echo "$RN $bin" | awk '{printf("%.3f\n",$1*$2)}'`
fi

#
# begin initial redux, flat fielding, bias subtraction, etc.
#
t0=`date +%s`

echo colibri_setup_redux.sh $file0
colibri_setup_redux.sh $file0

biasfile=bias_${cam}.fits
if [ -f "${workdir}/$biasfile" ]; then
    echo "Using biasfile ${workdir}/$biasfile"
else
    ln -s ${biasdir}/$biasfile $workdir
fi
darkbase=dark_${cam}
darkfile0=`ls ${workdir}/${darkbase}* 2>/dev/null | head -1`
if [ -f "$darkfile0" ]; then
    echo "Using darkfiles like $darkfile0"
else
    for darkfile0 in `ls ${darkdir}/${darkbase}*`; do
        ln -s $darkfile0 $workdir
    done
fi
flatfile=flat_${tag}.fits
if [ -f "${workdir}/$flatfile" ]; then
    echo "Using flatfile ${workdir}/$flatfile"
else
    ln -s ${flatdir}/$flatfile $workdir
fi

darks=`ls ${workdir}/dark_${cam}_*.fits`
exptimes=`ls $darks | awk -F_ '{print $NF}' | sed -e 's/\.fits//g'`

smt0=0
[ "$cam" = "C2" ] && smt0=4

# smt0 is starting point for smt keyword
# smt camera theta
# 0    C1    0            j + nr*i
# 1    C1    90           i+nc*(nr-1-j)
# 2    C1    180          nr-1-j+nr*(nc-1-i)
# 3    C1    270          nc-1-i+nc*j
# 4    C2    0            nc-1-j+nr*i
# 5    C2    90           i+nc*j
# 6    C2    180          j+nr*(nc-1-i)
# 7    C2    270          nc-1-i+nc*(nr-1-j) 

function base_redux() {
    local file=$1
    #
    # get the file bias section
    #
    local bsec=`gethead BIASSEC $file`
    local NY=`gethead ZNAXIS2 $file`
    local BIASSEC1=
    local BIASSEC2=
    local BIASSEC3=
    local BIASSEC4=
    if [ "$bsec" ]; then
        BIASSEC1=`echo $NY $NO | awk '{printf("[1:%d,1:%d]\n",$2,$1/2)}'`
        BIASSEC2=`echo $NY $NO | awk '{printf("[1:%d,%d:%d]\n",$2,$1/2+1,$1)}'`
        BIASSEC3=`echo $NY $NO | awk '{printf("[%d:%d,1:%d]\n",$1+$2+1,$1+$2*2,$1/2)}'`
        BIASSEC4=`echo $NY $NO | awk '{printf("[%d:%d,%d:%d]\n",$1+$2+1,$1+$2*2,$1/2+1,$1)}'`
    fi
    #
    # get the file data section
    #
    local dsec=`gethead DATASEC $file`
    local cx=`echo $dsec | tr '[:,]' ' ' | awk '{printf("%.0f\n",($2-$1+1)/2)}'`
    local cy=`echo $dsec | tr '[:,]' ' ' | awk '{printf("%.0f\n",($4-$3+1)/2)}'`
    if [ $ns -lt $NY ]; then # zoom in for narrow field case
        dsec=`echo $dsec | tr '[:,]' ' ' | awk '{printf("[%d:%d,%d:%d]\n", $1+'$cx'-'$ns'/2,$1+'$cx'+'$ns'/2-1,$3+'$cy'-'$ns'/2,$3+'$cy'+'$ns'/2-1)}'`
        cx=`echo $dsec | tr '[:,]' ' ' | awk '{printf("%.0f\n",($2-$1+1)/2)}'`
        cy=`echo $dsec | tr '[:,]' ' ' | awk '{printf("%.0f\n",($4-$3+1)/2)}'`
    fi
    cx=`echo $cx | awk '{printf("%.1f\n",$1+0.5)}'`
    cy=`echo $cy | awk '{printf("%.1f\n",$1+0.5)}'`
    #
    # get the calibration file section, same size as dsec
    #
    local csec=`echo $dsec | tr '[:,]' ' '  | awk '{dx=($2-$1+1)/2; dy=($4-$3+1)/2; printf("[%d:%d,%d:%d]\n",2048-dx+1,2048+dx,2048-dy+1,2048+dy)}'`
    # check mount rotation
    local smt=`gethead SMTMRO $file | awk '{print int($1)}'`
    local emt=`gethead EMTMRO $file | awk '{print int($1)}'`
    if [ "$smt" = "$emt" ]; then
        local bfile0=$2
        local med0_1=0
        local med0_2=0
        local med0_3=0
        local med0_4=0
        if [ "$BIASSEC1" ]; then
            med0_1=`immed "${file}${BIASSEC1}" 2>/dev/null`
        else
            med0_1=`gethead MED0_1 $workdir/$biasfile`
        fi
        if [ "$BIASSEC2" ]; then
            med0_2=`immed "${file}${BIASSEC2}" 2>/dev/null`
        else
            med0_2=`gethead MED0_2 $workdir/$biasfile`
        fi
        if [ "$BIASSEC3" ]; then
            med0_3=`immed "${file}${BIASSEC3}" 2>/dev/null`
        else
            med0_3=`gethead MED0_3 $workdir/$biasfile`
        fi
        if [ "$BIASSEC4" ]; then
            med0_4=`immed "${file}${BIASSEC4}" 2>/dev/null`
        else
            med0_4=`gethead MED0_4 $workdir/$biasfile`
        fi
        local med00=`echo $med0_1 $med0_2 $med0_3 $med0_4 | awk '{print ($1+$2+$3+$4)/4}' 2>/dev/null`
        local sky=`immed "${file}${dsec}" | awk '{sky=$1-('$med00'); if(sky<0) sky=0.; printf("%.2f\n",sky)}'`
        local exptime=`gethead EXPTIME $file`
        local igain=`echo $gain $exptime | awk '{print $1*$2}'`
        local skye=`echo $sky $exptime | awk '{printf("%.6f\n",$1/$2)}'`
        local sat=`echo $sat_level $sky $exptime | awk '{printf("%.6f\n",($1-$2)/$3)}'`
        local var0=`echo $RN $gain $sky $exptime | awk '{printf("%.6f\n", ($1*$1/$2 + $3)/($2*$4*$4))}'`
        smt=`gethead SMTMRO $file | awk '{printf("%.0f\n",$1/90+'$smt0')}'`
        emt=`gethead EMTMRO $file | awk '{printf("%.0f\n",$1/90+'$smt0')}'`
        local exptime0=`echo $exptimes | awk '{mn=1.e56; for (i=1;i<=NF;i++) {df=$i-'$exptime'; if (df<0) df=-df; if (df<mn) {mn=df;dt=$i}}; print dt}'`
        local darkfile=`ls ${workdir}/dark_${cam}_${exptime0}.fits 2>/dev/null`
	if [ -f "$darkfile" ]; then
	    if [ -f "${workdir}/$biasfile" ]; then
                echo imreduce "${file}${dsec}" "$workdir/${biasfile}${csec}" "${darkfile}${csec}" "$workdir/${flatfile}${csec}" $bfile0 ${bfile0%'.fits'}.wt.fits $var0 $med0_1 $med0_2 $med0_3 $med0_4 $smt
                imreduce "${file}${dsec}" "$workdir/${biasfile}${csec}" "${darkfile}${csec}" "$workdir/${flatfile}${csec}" $bfile0 ${bfile0%'.fits'}.wt.fits $var0 $med0_1 $med0_2 $med0_3 $med0_4 $smt
	    else
                echo imreduce1 "${file}${dsec}" "${darkfile}${csec}" "$workdir/${flatfile}${csec}" $bfile0 ${bfile0%'.fits'}.wt.fits $var0 $med0_1 $med0_2 $med0_3 $med0_4 $smt
                imreduce1 "${file}${dsec}" "${darkfile}${csec}" "$workdir/${flatfile}${csec}" $bfile0 ${bfile0%'.fits'}.wt.fits $var0 $med0_1 $med0_2 $med0_3 $med0_4 $smt
            fi
	else
            echo imreduce0 "${file}${dsec}" "$workdir/${biasfile}${csec}" "$workdir/${flatfile}${csec}" $bfile0 ${bfile0%'.fits'}.wt.fits $var0 $med0_1 $med0_2 $med0_3 $med0_4 $smt
            imreduce0 "${file}${dsec}" "$workdir/${biasfile}${csec}" "$workdir/${flatfile}${csec}" $bfile0 ${bfile0%'.fits'}.wt.fits $var0 $med0_1 $med0_2 $med0_3 $med0_4 $smt
	fi
        local edte=`gethead EDATE $bfile0`
        #sethead DATE-OBE=$edte CTYPE1='RA---TAN' CTYPE2='DEC--TAN' CD1_1=-$ps CD2_2=$ps CD2_1=0.0 CD1_2=0.0 CRPIX1=$cx CRPIX2=$cy CRVAL1=30.0 CRVAL2=0.0 SKYLEV=$skye SATURATE=$sat GAIN=$igain VAR0=$var0 MATCHED=0 NMATCHED=0 PV1_1=1.0 PV2_1=1.0 PV1_7=$p1 PV1_9=$p1 PV2_7=$p1 PV2_9=$p1 $bfile0
        sethead DATE-OBE=$edte CTYPE1='RA---TAN' CTYPE2='DEC--TAN' CD1_1=-$ps CD2_2=$ps CD2_1=0.0 CD1_2=0.0 CRPIX1=$cx CRPIX2=$cy CRVAL1=30.0 CRVAL2=0.0 SKYLEV=$skye SATURATE=$sat GAIN=$igain VAR0=$var0 MATCHED=0 NMATCHED=0 $bfile0
    else
        echo "skipping file $file , (SMTRO/EMTRO=${smt}/${emt})"
    fi
}

rm ${workdir}/old_$file_list ${workdir}/new_$file_list 2>/dev/null
for file in `cat $file_list`; do
    bfile=`basename $file`
    bfile0=${workdir}/${bfile%'.fz'}
    [ -f $bfile0 ] || {
        filter0=`gethead FILTER $file`
        [ "$filter0" = "$filter" ] && {
            base_redux $file $bfile0 &
            gonogo
        }
    }
done
wait; go_iter=0
for file in `cat $file_list`; do
    bfile=`basename $file`
    bfile0=${bfile%'.fz'}
    ls ${workdir}/$bfile0 2>/dev/null | awk -F/ '{print $NF}'
done > ${workdir}/$file_list
cd $workdir

date +%s | awk '{printf("Task Initial: %.2f minutes\n",($1-'$t0')/60.)}'
echo 1 > current_state.txt

#
# the images have been reduced, now we need to find stars and align
#
t0=`date +%s`

cp $file_list matched_$file_list
if [ -s matched_$file_list ]; then
    use_nstars_min=`echo $ns $nstars_min | awk '{f=$1/1024; printf("%.0f\n",f*f*$2)}'`
    echo align_colibri.sh matched_$file_list nstars_min=$use_nstars_min inst=$inst
    align_colibri.sh matched_$file_list nstars_min=$use_nstars_min inst=$inst
fi

date +%s | awk '{printf("Task Alignment: %.2f minutes\n",($1-'$t0')/60.)}'

# now we stack all the aligned files
nstack0=0
[ -f nstack_last.txt ] && nstack0=`cat nstack_last.txt`
nstack=`cat matched_$file_list | wc -l`

if [ "$nstack" -gt 1 ]; then
    echo 2 > current_state.txt   # successful alignment
else
    rm stack_${cam}.fits 2>/dev/null
fi

if [ "$nstack" -gt 1 -a "$nstack" -gt "$nstack0" ]; then
    #
    # do the stacking
    #
    t0=`date +%s`
    rm stack_${cam}.fits 2>/dev/null

    echo "Stacking $nstack, well-matched files..."

    [ "$nstack" -lt 5 ] && do_nir_sky=no

    echo stack_colibri.sh matched_$file_list mask_sigma=$mask_sigma bg_order=$bg_order do_nir_sky=$do_nir_sky inst=$inst catdir=$catdir gain=$gain new_mask=$new_mask ps=$ps
    stack_colibri.sh matched_$file_list mask_sigma=$mask_sigma bg_order=$bg_order do_nir_sky=$do_nir_sky inst=$inst catdir=$catdir gain=$gain new_mask=$new_mask ps=$ps

    [ -f stack_${cam}.fits ] && echo $nstack > nstack_last.txt

    date +%s | awk '{printf("Task Stack Frames: %.2f minutes\n",($1-'$t0')/60.)}'
fi

if [ -f stack_${cam}.fits ]; then
    #
    # take a break to make the chi^2 stack
    #
    echo 3 > current_state.txt   # successful stacking
    t0=`date +%s`

    if [ "$full_stack" = "yes" ]; then
        [ "$cam" = "C2" ] && sleep 10  # try to avoid a race condition
        cd $workbase
        echo make_full_stack.sh catdir=$catdir snr_cut=$snr_cut
        make_full_stack.sh catdir=$catdir snr_cut=$snr_cut
        cd $workdir

        date +%s | awk '{printf("Task Full Stack: %.2f minutes\n",($1-'$t0')/60.)}'
        echo 4 > current_state.txt
    fi

    #
    # do the photometry
    #
    t0=`date +%s`
 
    if [ "$use_ddoti_phot" = "yes" ]; then
        echo colibri_phot_ddoti.sh fmatched_$file_list catdir=$catdir detect_thresh=$detect_thresh mask_sigma=$mask_sigma do_dao=$do_dao
        colibri_phot_ddoti.sh fmatched_$file_list catdir=$catdir detect_thresh=$detect_thresh mask_sigma=$mask_sigma do_dao=$do_dao
    else
        echo colibri_phot.sh fmatched_$file_list catdir=$catdir detect_thresh=$detect_thresh do_dao=$do_dao
        colibri_phot.sh fmatched_$file_list catdir=$catdir detect_thresh=$detect_thresh do_dao=$do_dao
    fi

    date +%s | awk '{printf("Task Photometry: %.2f minutes\n",($1-'$t0')/60.)}'
    echo 5 > current_state.txt

    #
    # now collect everything and make some summary plots and pages
    #
    t0=`date +%s`

    if [ "$use_ddoti_phot" = "yes" ]; then
        nfiles=`cat fmatched_$file_list | wc -l`
        echo ddoti_summary.sh fmatched_$file_list cam=$cam savedir=$here t00=$t00 nfiles=$nfiles snr_cut=$snr_cut
        ddoti_summary.sh fmatched_$file_list cam=$cam savedir=$here t00=$t00 nfiles=$nfiles snr_cut=$snr_cut
    else
        echo colibri_summary.sh fmatched_$file_list savedir=$here make_frame_jpegs=$make_frame_jpegs catdir=$catdir logfile=$logfile
        colibri_summary.sh fmatched_$file_list savedir=$here make_frame_jpegs=$make_frame_jpegs catdir=$catdir logfile=$logfile
    fi

    date +%s | awk '{printf("Task Summarize: %.2f minutes\n",($1-'$t0')/60.)}'
    echo 6 > current_state.txt
else
    echo 0 > current_state.txt
    failed=yes
fi

rm force_cleanup.txt 2>/dev/null
force_cleanup=`echo $nstack $nfiles0 | awk '{if($1<0.5*$2) print 1; else print 0}'`
if [ $force_cleanup -eq 1 ]; then
    echo "Only $nstack of $nfiles0 files were aligned/stacked, forcing cleanup next time..."
    touch force_cleanup.txt
fi

[ "$cleanup" = "yes" ] && echo "Cleaning up, removing $workdir"
date -u
if [ "$failed" = "yes" ]; then
    cp $logfile ${here}/"failed_"$logfile
else
    final_logfile=${here}/$logfile
    [ -f "logfile_name.txt" ] && final_logfile=`cat logfile_name.txt`
    cp $logfile $final_logfile
fi
if [ "$cleanup" = "yes" ]; then
    cd $here
    rm -r $workdir
fi
